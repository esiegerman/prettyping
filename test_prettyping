#!/usr/bin/env python3

# Read parse_arguments() function to understand how this script works.
# Alternatively, run this script with --help.

import argparse
import os
import os.path
import shlex
import signal
import subprocess
import sys
import textwrap
import time

OPTIONS = None
COLOR_RESET = '\033[0m'
COLOR_RED = '\033[0;31m'
COLOR_GREEN = '\033[0;32m'
COLOR_YELLOW = '\033[0;33m'
COLOR_BLUE = '\033[0;34m'
COLOR_MAGENTA = '\033[0;35m'
COLOR_CYAN = '\033[0;36m'


def hr(text, char='-✂-', qty=10, color_set=COLOR_CYAN, color_reset=COLOR_RESET):
    '''Returns a string padded with <char> repeated <qty> times.

    Also adds TTY color escapes to the string.
    '''
    return '{pad} {color_set}{text}{color_reset} {pad}'.format(
        text=text, pad=(char * qty), color_set=color_set, color_reset=color_reset)


class TestDef():
    '''The definition of a test.'''

    def __init__(self, name, description, ping_output):
        self.index = None
        self.name = name
        self.description = description
        self.ping_output = ping_output.strip().splitlines()

    def emulate_ping(self):
        '''Emulate the behavior of a ping binary. (i.e. mocking)

        This will print predefined lines with pauses between them.
        It will also handle Ctrl+C correctly.
        '''
        i = iter(self.ping_output)
        try:
            for line in i:
                # The first character indicates the action.
                # . → Insert a pause before printing the line.
                # | → Print the line without pausing.
                # ! → Print the line without pausing. Also marks the beginning
                #     of the text that is printed even after Ctrl+C is pressed.
                if line[0] == '.':
                    # Short, common pause.
                    time.sleep(OPTIONS.interval)
                elif line[0] == '|' or line[0] == '!':
                    # No pause.
                    pass
                else:
                    raise NotImplementedError('Character "{0}" is not recognized'.format(line[0]))
                sys.stdout.write(line[1:] + '\n')
                sys.stdout.flush()
        except KeyboardInterrupt:
            # Skip to the trailing section.
            trailing_found = False
            for line in i:
                if line[0] == '!':
                    trailing_found = True
                if trailing_found:
                    sys.stdout.write(line[1:] + '\n')
            sys.stdout.flush()

    def build_prettyping_cmdline(self):
        return [
            './prettyping',
            '--pingbin', os.path.abspath(sys.argv[0]),
            # prettyping doesn't recognize these, so it passes them through to ${pingbin}
            '--interval', str(OPTIONS.interval),
            '--emulate_ping', str(self.index) if self.index is not None else self.name,
        ]

    def run(self):
        '''Run the test

        This will call the prettyping executable with the correct parameters.
        '''

        print(hr('DESCRIPTION'))
        print('{color}Test #{index}:{reset} {name}'.format(
            index=self.index, name=self.name, color=COLOR_CYAN, reset=COLOR_RESET))
        print(self.description)

        cmdline = self.build_prettyping_cmdline()
        print(' '.join(shlex.quote(arg) for arg in cmdline))

        if OPTIONS.wait:
            input('Press Enter to begin the test.')

        prettyping = None
        try:
            print(hr('BEGIN'))
            sys.stdout.flush()
            sys.stderr.flush()
            prettyping = subprocess.Popen(cmdline)
            prettyping.wait()
        except KeyboardInterrupt:
            if prettyping:
                prettyping.wait()
        print(hr('END'))


# This starts as a list (in the source code), but is later (at runtime)
# converted to a dict.
TESTS = [
    TestDef(
        'Sample test',
        'First test ever written in the new testing tool.',
'''
|PING registro.br (200.160.2.3) 56(84) bytes of data.
.Request timeout for icmp_seq 1
.64 bytes from registro.br (200.160.2.3): icmp_seq=2 ttl=56 time=25.5 ms
.64 bytes from registro.br (200.160.2.3): icmp_seq=3 ttl=56 time=55.7 ms
.64 bytes from registro.br (200.160.2.3): icmp_seq=4 ttl=56 time=75.2 ms
!
|--- registro.br ping statistics ---
|3 packets transmitted, 3 received, 0% packet loss, time 2000ms
|rtt min/avg/max/mdev = 36.750/38.535/40.048/1.360 ms
''',
    ),
    TestDef(
        'Abrupt end of output',
        'prettyping should print the statistics and fix the cursor position.',
'''
|PING registro.br (200.160.2.3) 56(84) bytes of data.
.64 bytes from registro.br (200.160.2.3): icmp_seq=1 ttl=56 time=25.5 ms
.64 bytes from registro.br (200.160.2.3): icmp_seq=2 ttl=56 time=55.7 ms
''',
    ),
]
TEST_NAMES = []


def parse_arguments():
    parser = argparse.ArgumentParser(
        description='prettyping testing tool',
        epilog=textwrap.dedent('''
        This tool serves two purposes:

        * Act as a user-friendly front-end for running predefined prettyping tests.
        * Emulate a mock ping implementation while running a predefined test.

        There is no automated check for test results. The testing is essentially
        visual, a human being looks at the behavior and checks if the prettyping
        behavior makes sense.
        '''),
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument(
        '--emulate_ping',
        metavar='TEST_ID',
        action='store',
        type=str,
        help='Behaves as a mock version of ping.'
    )
    parser.add_argument(
        '-t', '--test',
        metavar='TEST_ID',
        action='store',
        type=str,
        help='The test to run.'
    )
    parser.add_argument(
        '-a', '--all',
        action='store_true',
        help='Runs all tests sequentially.'
    )
    parser.add_argument(
        '-i', '--interval',
        metavar='SECONDS',
        action='store',
        type=float,
        default=1,
        help='The sleep() interval before each line is printed.'
    )
    parser.add_argument(
        '-w', '--wait',
        action='store_true',
        help='Waits for input before running a test.'
    )
    args = parser.parse_args()
    return args


def convert_global_tests_list_to_dict():
    global TESTS, TEST_NAMES
    TEST_NAMES = []
    d = {}
    for i, t in enumerate(TESTS):
        # Tests can be referenced by number (zero-based index) or by name.
        d[t.name] = t
        d[i] = t
        d[str(i)] = t
        t.index = i
        TEST_NAMES.append(t.name)
    TESTS = d


def raise_keyboard_interrupt(*args):
    raise KeyboardInterrupt()


def main():
    global OPTIONS
    OPTIONS = parse_arguments()

    convert_global_tests_list_to_dict()

    if OPTIONS.emulate_ping:
        if OPTIONS.all or OPTIONS.test:
            print('Error: --emulate_ping cannot be used together with --all or --test.')
            sys.exit(1)

        # KeyboardInterrupt seems to be raised only when in interactive shell.
        # If Python interpreted was launched by another script, then we need to
        # manually set a handler for SIGINT.
        # https://stackoverflow.com/questions/974189/how-to-send-a-sigint-to-python-from-a-bash-script
        signal.signal(signal.SIGINT, raise_keyboard_interrupt)

        TESTS[OPTIONS.emulate_ping].emulate_ping()
    else:
        if OPTIONS.all and OPTIONS.test:
            print('Error: --all and --test cannot be used together.')
            sys.exit(1)

        if OPTIONS.test:
            TESTS[OPTIONS.test].run()
        elif OPTIONS.all:
            for i in range(len(TEST_NAMES)):
                TESTS[i].run()
        else:
            print('Available tests:')
            for i, name in enumerate(TEST_NAMES):
                print('  {0}: {1}'.format(i, name))


if __name__ == '__main__':
	main()
